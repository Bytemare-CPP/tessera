name: Tessera CI/CD

on:
  push:
    branches: [ main, deploy ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22.14.0'
          cache: 'npm'
      - name: Install dependencies
        run: npm ci
      - name: Run tests
        run: npm test
        env:
          VITE_SUPABASE_URL: "https://example.supabase.co"
          VITE_SUPABASE_KEY: "dummy-key-for-testing"

  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22.14.0'
          cache: 'npm'
          
      # Frontend build process - runs at the repository root
      - name: Install frontend dependencies
        run: npm ci
          
      - name: Build frontend
        run: npm run build
        env:
          VITE_SUPABASE_URL: ${{ secrets.VITE_SUPABASE_URL }}
          VITE_SUPABASE_KEY: ${{ secrets.VITE_SUPABASE_KEY }}
          
      # Backend build process - runs in the server directory
      - name: Install server dependencies
        run: |
          cd server
          npm ci
          
      - name: Build server
        run: |
          cd server
          npm run build
          
      # Upload artifacts for deployment
      - name: Upload frontend build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build
          path: dist/
          
      - name: Upload server build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: server-build
          path: server/
          
      - name: Upload package files
        uses: actions/upload-artifact@v4
        with:
          name: package-files
          path: |
            package.json
            package-lock.json
          
  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/deploy'
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: frontend-build
          path: dist/
          
      - uses: actions/download-artifact@v4
        with:
          name: server-build
          path: server/
          
      - uses: actions/download-artifact@v4
        with:
          name: package-files
          path: ./
          
      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
          
      - name: Add EC2 host to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts
          
      - name: Deploy to EC2
        run: |
          # List files to verify what we have
          echo "Files to deploy:"
          ls -la
          ls -la server/
          
          # Create directories
          ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "mkdir -p ~/tessera/server"
          
          # Transfer frontend files
          rsync -avz --delete dist/ ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:~/tessera/dist/
          
          # Transfer package files
          rsync -avz package.json package-lock.json ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:~/tessera/
          
          # Transfer server files
          rsync -avz server/ ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:~/tessera/server/
          
          # Create server environment file FIRST
          ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "echo 'SUPABASE_URL=${{ secrets.SUPABASE_URL }}' > ~/tessera/server/.env"
          ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "echo 'SUPABASE_SERVICE_ROLE_KEY=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}' >> ~/tessera/server/.env"
          ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "echo 'VIBE_MATCHER_URL=https://www.tessera.it.com/vibe' >> ~/tessera/server/.env"
          ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "echo 'ALLOWED_ORIGINS=https://www.tessera.it.com,https://tessera.it.com,http://www.tessera.it.com,http://tessera.it.com,http://54.82.27.27,*' >> ~/tessera/server/.env"
          
          # THEN install dependencies
          ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} 'cd ~/tessera/server && npm ci --production'
          
          # FINALLY start server with PM2
          ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} 'cd ~/tessera/server && pm2 delete tessera-api || echo "No previous process to delete"; pm2 start dist/index.js --name tessera-api'
          
          # Save PM2 configuration
          ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} 'pm2 save'
          
      - name: Deploy Vibe Matcher with HuggingFace API
        run: |
          # Create vibe matcher directory
          ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "mkdir -p ~/tessera/vibe_matcher"
          
          # Create the vibe matcher service
          ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "cat > ~/tessera/vibe_matcher/vibe_matcher.py << 'EOT'
          from fastapi import FastAPI, UploadFile, File, Form, HTTPException
          from fastapi.middleware.cors import CORSMiddleware
          import uvicorn
          import os
          import base64
          import json
          import requests
          import random
          from dotenv import load_dotenv

          # Load environment variables
          load_dotenv()
          app = FastAPI()

          # Add CORS middleware
          app.add_middleware(
              CORSMiddleware,
              allow_origins=['*'],
              allow_credentials=True,
              allow_methods=['*'],
              allow_headers=['*'],
          )

          # HuggingFace API configuration
          HF_API_TOKEN = os.getenv('HF_API_TOKEN')
          CLIP_MODEL_API = 'https://api-inference.huggingface.co/models/openai/clip-vit-large-patch14'
          
          @app.post('/match')
          async def match_vibes(image: UploadFile = File(...), prompt: str = Form(...)):
              try:
                  # Read image content
                  content = await image.read()
                  
                  # Convert image to base64 for HuggingFace API
                  image_b64 = base64.b64encode(content).decode('utf-8')
                  
                  # Call CLIP model to calculate similarity between image and text
                  headers = {'Authorization': f'Bearer {HF_API_TOKEN}'}
                  payload = {
                      'inputs': {
                          'image': image_b64,
                          'text': prompt
                      }
                  }
                  
                  response = requests.post(CLIP_MODEL_API, headers=headers, json=payload)
                  
                  # Check response
                  if response.status_code == 200:
                      result = response.json()
                      return {
                          'score': result['score'],
                          'status': 'success',
                          'message': f'Image-text similarity score: {result["score"]:.4f}'
                      }
                      
                  # Handle model loading case
                  elif response.status_code == 503 and 'loading' in response.text:
                      # Use fallback scoring while model loads
                      return {
                          'score': 0.5 + (random.random() * 0.3),  # Random score between 0.5-0.8
                          'status': 'loading',
                          'message': 'Model is loading, using estimated score'
                      }
                      
                  # Handle other errors
                  else:
                      print(f'HuggingFace API error: {response.status_code} {response.text}')
                      return {
                          'score': 0.5,
                          'status': 'error',
                          'message': f'API error: {response.status_code}'
                      }
                      
              except Exception as e:
                  print(f'Error in match_vibes: {str(e)}')
                  # Fallback response
                  return {
                      'score': 0.5,
                      'status': 'fallback',
                      'message': 'Using fallback scoring due to error',
                      'error': str(e)
                  }
          
          @app.get('/health')
          def health_check():
              return {'status': 'ok', 'service': 'vibe-matcher'}
          
          if __name__ == '__main__':
              port = int(os.getenv('PORT', 8000))
              uvicorn.run(app, host='0.0.0.0', port=port)
          EOT"
          
          # Install dependencies
          ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "sudo dnf install -y python3-pip"
          ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "python3 -m pip install --user fastapi uvicorn python-dotenv python-multipart requests"
          
          # Create environment file with HuggingFace API token
          ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "echo 'HF_API_TOKEN=${{ secrets.HF_API_TOKEN }}' > ~/tessera/vibe_matcher/.env"
          ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "echo 'PORT=8000' >> ~/tessera/vibe_matcher/.env"
          
          # Start the vibe matcher service with PM2
          ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "cd ~/tessera/vibe_matcher && pm2 delete vibe-matcher 2>/dev/null || echo 'No previous service'; pm2 start 'python3 vibe_matcher.py' --name vibe-matcher; pm2 save"
          
      - name: Set up Nginx for API routing with HTTPS
        run: |
          # Create the Nginx configuration file with proper formatting
          cat > nginx.conf << 'EOT'
          # HTTP server - redirects to HTTPS
          server {
              listen 80;
              server_name tessera.it.com www.tessera.it.com;
              
              # Redirect all traffic to HTTPS
              location / {
                  return 301 https://$host$request_uri;
              }
          }

          # HTTPS server
          server {
              listen 443 ssl;
              server_name tessera.it.com www.tessera.it.com;
              
              # SSL configuration
              ssl_certificate /etc/letsencrypt/live/tessera.it.com/fullchain.pem;
              ssl_certificate_key /etc/letsencrypt/live/tessera.it.com/privkey.pem;
              ssl_protocols TLSv1.2 TLSv1.3;
              
              # Increase upload size limit globally
              client_max_body_size 20M;

              # Add CORS headers for all responses
              add_header 'Access-Control-Allow-Origin' '$http_origin' always;
              add_header 'Access-Control-Allow-Credentials' 'true' always;
              add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS' always;
              add_header 'Access-Control-Allow-Headers' 'Accept,Authorization,Cache-Control,Content-Type,DNT,If-Modified-Since,Keep-Alive,Origin,User-Agent,X-Requested-With' always;

              # Vibe Matcher API
              location /vibe/ {
                  proxy_pass http://localhost:8000/;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade $http_upgrade;
                  proxy_set_header Connection "upgrade";
                  proxy_set_header Host $host;
                  proxy_cache_bypass $http_upgrade;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
                  
                  # Handle file uploads
                  client_max_body_size 20M;
                  
                  # Handle OPTIONS requests for CORS
                  if ($request_method = 'OPTIONS') {
                      add_header 'Access-Control-Allow-Origin' '$http_origin' always;
                      add_header 'Access-Control-Allow-Credentials' 'true' always;
                      add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS' always;
                      add_header 'Access-Control-Allow-Headers' 'Accept,Authorization,Cache-Control,Content-Type,DNT,If-Modified-Since,Keep-Alive,Origin,User-Agent,X-Requested-With' always;
                      add_header 'Access-Control-Max-Age' 1728000;
                      add_header 'Content-Type' 'text/plain charset=UTF-8';
                      add_header 'Content-Length' 0;
                      return 204;
                  }
              }

              # API requests with CORS handling
              location /api/ {
                  proxy_pass http://localhost:4000;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade $http_upgrade;
                  proxy_set_header Connection "upgrade";
                  proxy_set_header Host $host;
                  proxy_cache_bypass $http_upgrade;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
                  
                  # Handle file uploads for API too
                  client_max_body_size 20M;
                  
                  # Handle OPTIONS requests for CORS
                  if ($request_method = 'OPTIONS') {
                      add_header 'Access-Control-Allow-Origin' '$http_origin' always;
                      add_header 'Access-Control-Allow-Credentials' 'true' always;
                      add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS' always;
                      add_header 'Access-Control-Allow-Headers' 'Accept,Authorization,Cache-Control,Content-Type,DNT,If-Modified-Since,Keep-Alive,Origin,User-Agent,X-Requested-With' always;
                      add_header 'Access-Control-Max-Age' 1728000;
                      add_header 'Content-Type' 'text/plain charset=UTF-8';
                      add_header 'Content-Length' 0;
                      return 204;
                  }
              }

              # Frontend files
              location / {
                  root /home/${{ secrets.EC2_USERNAME }}/tessera/dist;
                  index index.html;
                  try_files $uri $uri/ /index.html;
              }

              # Error pages
              error_page 404 /404.html;
              error_page 500 502 503 504 /50x.html;
              location = /50x.html {
                  root /usr/share/nginx/html;
              }
          }
          EOT
          
          # Transfer and install the Nginx config
          rsync -avz nginx.conf ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:~/tessera.conf
          ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} 'sudo mv ~/tessera.conf /etc/nginx/conf.d/tessera.conf && sudo nginx -t && sudo systemctl restart nginx'
          
      - name: Check SSL Certificate Status
        run: |
          ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} 'sudo certbot certificates'